# AI Development Configuration
# Contains worktree helpers, Cursor integration, and other AI-assisted development tools

# Git Worktree Helpers
# Create a new worktree with dynamic repository detection and smart dependency installation
wt-new() {
  local task="$1"
  [ -z "$task" ] && { echo "usage: wt-new <branch-name>"; return 1; }
  
  # Detect repository info dynamically
  local remote_url=$(git remote get-url origin 2>/dev/null)
  local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
  
  # Fallback to common branch names if detection fails
  if [ -z "$default_branch" ]; then
    if git show-ref --verify --quiet refs/remotes/origin/main; then
      default_branch="main"
    elif git show-ref --verify --quiet refs/remotes/origin/master; then
      default_branch="master"
    else
      echo "Error: Could not determine default branch. Please ensure you have a remote 'origin' configured."
      return 1
    fi
  fi
  
  echo "Creating worktree for branch: $task"
  echo "Using default branch: $default_branch"
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit task name length to avoid path length issues (max ~30 chars for task to account for overmind/tmux additions)
  local truncated_task="${task:0:30}"
  if [ "${#task}" -gt 30 ]; then
    echo "Warning: Task name truncated from '${task}' to '${truncated_task}' to avoid path length issues with overmind/tmux"
  fi
  
  local worktree_path="../${base_name}-wt-${truncated_task}"

  # Ensure local main branch is up to date before creating worktree
  echo "Ensuring local $default_branch branch is up to date..."
  git fetch origin
  git pull origin "$default_branch"
  
  # Check if branch already exists
  if git show-ref --verify --quiet refs/heads/"$task"; then
    echo "Branch '$task' already exists, creating worktree without -b flag"
    git worktree add "$worktree_path" "$task"
  else
    echo "Creating new branch '$task'"
    git worktree add -b "$task" "$worktree_path" "$default_branch"
  fi
  
  if [ $? -eq 0 ]; then
    echo "Worktree created at $worktree_path"
    echo "Installing dependencies..."
    
    # Check if this is a Ruby project and install dependencies
    if [ -f "$worktree_path/Gemfile" ] && command -v bundle >/dev/null; then
      echo "Detected Ruby project - running bundle install..."
      (cd "$worktree_path" && bundle install)
    fi
    
    # Check if this is a Node.js project and install dependencies
    if [ -f "$worktree_path/package.json" ] && command -v yarn >/dev/null; then
      echo "Detected Node.js project - running yarn install..."
      (cd "$worktree_path" && yarn install)
    elif [ -f "$worktree_path/package.json" ] && command -v npm >/dev/null; then
      echo "Detected Node.js project - running npm install..."
      (cd "$worktree_path" && npm install)
    fi
    
    # Check for Python projects
    if [ -f "$worktree_path/pyproject.toml" ] && command -v poetry >/dev/null; then
      echo "Detected Poetry project - running poetry install..."
      (cd "$worktree_path" && poetry install)
    elif [ -f "$worktree_path/requirements.txt" ] && command -v pip >/dev/null; then
      echo "Detected Python project - running pip install..."
      (cd "$worktree_path" && pip install -r requirements.txt)
    fi
    
    # Copy .env file from main repo to worktree if it exists
    if [ -f "$repo_root/.env" ]; then
      echo "Copying .env file from main repository..."
      cp "$repo_root/.env" "$worktree_path/.env"
    elif [ -f "$repo_root/.env.example" ]; then
      echo "Copying .env.example file from main repository..."
      cp "$repo_root/.env.example" "$worktree_path/.env"
    else
      echo "No .env or .env.example file found in main repository - skipping environment setup"
    fi
    
    echo "Worktree ready! Use 'wt-enter $task' to navigate to it."
    echo "Repository: $remote_url"
    echo "Default branch: $default_branch"
  else
    echo "Failed to create worktree"
    return 1
  fi
}

# Remove worktree + branch (after merge)
wt-clean() {
  local task="$1"
  [ -z "$task" ] && { echo "usage: wt-clean <branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit task name length to match wt-new function
  local truncated_task="${task:0:30}"
  local worktree_path="../${base_name}-wt-${truncated_task}"
  
  echo "Cleaning up worktree: $task"
  git worktree remove "$worktree_path" || return 1
  git branch -d "$task" 2>/dev/null || echo "Branch not merged; use 'git branch -D $task' to force."
  git fetch -p
  echo "Worktree cleaned up!"
}

# Quick navigation to worktree
wt-enter() {
  local task="$1"
  [ -z "$task" ] && { echo "usage: wt-enter <branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit task name length to match wt-new function
  local truncated_task="${task:0:30}"
  local worktree_path="../${base_name}-wt-${truncated_task}"
  
  if [ -d "$worktree_path" ]; then
    cd "$worktree_path"
  else
    echo "Worktree $worktree_path not found. Use 'wt-new $task' to create it."
    return 1
  fi
}

# List all worktrees
wt-list() {
  echo "Active worktrees:"
  git worktree list
}

# Get repository info for current directory
wt-info() {
  local remote_url=$(git remote get-url origin 2>/dev/null)
  local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
  local current_branch=$(git branch --show-current 2>/dev/null)
  
  echo "Repository Information:"
  echo "  Remote URL: $remote_url"
  echo "  Default branch: $default_branch"
  echo "  Current branch: $current_branch"
  echo "  Project type: $(wt-detect-project-type)"
}

# Detect project type based on files present
wt-detect-project-type() {
  local types=()
  
  if [ -f "Gemfile" ]; then
    types+=("Ruby")
  fi
  
  if [ -f "package.json" ]; then
    types+=("Node.js")
  fi
  
  if [ -f "pyproject.toml" ]; then
    types+=("Python (Poetry)")
  elif [ -f "requirements.txt" ]; then
    types+=("Python (pip)")
  fi
  
  if [ ${#types[@]} -eq 0 ]; then
    echo "Unknown"
  else
    echo "${types[*]}"
  fi
}

# Cursor-specific helpers
cursor-open-worktree() {
  local task="$1"
  [ -z "$task" ] && { echo "usage: cursor-open-worktree <branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit task name length to match wt-new function
  local truncated_task="${task:0:30}"
  local worktree_path="../${base_name}-wt-${truncated_task}"
  
  if [ -d "$worktree_path" ]; then
    echo "Opening Cursor with worktree: $worktree_path"
    cursor "$worktree_path"
  else
    echo "Worktree $worktree_path not found. Use 'wt-new $task' to create it."
    return 1
  fi
}

# Rename existing worktree to shorter name to avoid path length issues
wt-rename() {
  local old_task="$1"
  local new_task="$2"
  [ -z "$old_task" ] || [ -z "$new_task" ] && { echo "usage: wt-rename <old-branch-name> <new-branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit new task name length
  local truncated_new_task="${new_task:0:30}"
  if [ "${#new_task}" -gt 30 ]; then
    echo "Warning: New task name truncated from '${new_task}' to '${truncated_new_task}' to avoid path length issues with overmind/tmux"
  fi
  
  local old_worktree_path="../${base_name}-wt-${old_task}"
  local new_worktree_path="../${base_name}-wt-${truncated_new_task}"
  
  if [ ! -d "$old_worktree_path" ]; then
    echo "Error: Worktree '$old_worktree_path' not found"
    return 1
  fi
  
  if [ -d "$new_worktree_path" ]; then
    echo "Error: Worktree '$new_worktree_path' already exists"
    return 1
  fi
  
  echo "Renaming worktree from '$old_task' to '$truncated_new_task'"
  echo "Old path: $old_worktree_path"
  echo "New path: $new_worktree_path"
  
  # Rename the worktree directory
  mv "$old_worktree_path" "$new_worktree_path"
  
  # Update the worktree's git configuration to point to the new path
  (cd "$new_worktree_path" && git config --local --replace-all core.worktree "$new_worktree_path")
  
  echo "Worktree renamed successfully!"
  echo "You can now use 'wt-enter $truncated_new_task' to navigate to it."
}

# Claude/Anthropic helpers (placeholder for future Claude integration)
claude-analyze() {
  local file="$1"
  [ -z "$file" ] && { echo "usage: claude-analyze <file>"; return 1; }
  
  if [ -f "$file" ]; then
    echo "Analyzing $file with Claude..."
    # Future integration with Claude API
    echo "Claude analysis feature coming soon..."
  else
    echo "File $file not found."
    return 1
  fi
}

# AI development environment setup
ai-setup() {
  echo "Setting up AI development environment..."
  
  # Check for required tools
  local missing_tools=()
  
  if ! command -v git >/dev/null; then
    missing_tools+=("git")
  fi
  
  if ! command -v cursor >/dev/null; then
    echo "Warning: Cursor not found in PATH. Install from https://cursor.com/downloads"
  fi
  
  if [ ${#missing_tools[@]} -gt 0 ]; then
    echo "Missing required tools: ${missing_tools[*]}"
    return 1
  fi
  
  echo "AI development environment ready!"
  echo "Available commands:"
  echo "  wt-new <branch>     - Create new worktree"
  echo "  wt-enter <branch>   - Navigate to worktree"
  echo "  wt-clean <branch>   - Clean up worktree"
  echo "  wt-list            - List worktrees"
  echo "  wt-info            - Show repo info"
  echo "  cursor-open-worktree <branch> - Open worktree in Cursor"
}
