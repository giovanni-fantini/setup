# AI Development Configuration
# Contains worktree helpers, Cursor integration, and other AI-assisted development tools

# Git Worktree Helpers
# Create a new worktree with dynamic repository detection and smart dependency installation
wt-new() {
  local task="$1"
  [ -z "$task" ] && { echo "usage: wt-new <branch-name>"; return 1; }
  
  # Detect repository info dynamically
  local remote_url=$(git remote get-url origin 2>/dev/null)
  local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
  
  # Fallback to common branch names if detection fails
  if [ -z "$default_branch" ]; then
    if git show-ref --verify --quiet refs/remotes/origin/main; then
      default_branch="main"
    elif git show-ref --verify --quiet refs/remotes/origin/master; then
      default_branch="master"
    else
      echo "Error: Could not determine default branch. Please ensure you have a remote 'origin' configured."
      return 1
    fi
  fi
  
  echo "Creating worktree for branch: $task"
  echo "Using default branch: $default_branch"
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit task name length to avoid path length issues (max ~30 chars for task to account for overmind/tmux additions)
  local truncated_task="${task:0:30}"
  if [ "${#task}" -gt 30 ]; then
    echo "Warning: Task name truncated from '${task}' to '${truncated_task}' to avoid path length issues with overmind/tmux"
  fi
  
  local worktree_path="../${base_name}-wt-${truncated_task}"

  # Ensure local main branch is up to date before creating worktree
  echo "Ensuring local $default_branch branch is up to date..."
  git fetch origin
  git pull origin "$default_branch"
  
  # Check if branch already exists locally or on origin
  if git show-ref --verify --quiet refs/heads/"$task"; then
    echo "Branch '$task' already exists locally, creating worktree without -b flag"
    git worktree add "$worktree_path" "$task"
  elif git show-ref --verify --quiet refs/remotes/origin/"$task"; then
    echo "Remote branch 'origin/$task' found. Creating local tracking branch and worktree..."
    # Create local branch tracking the remote
    git branch --track "$task" "origin/$task" 2>/dev/null || git branch "$task" "origin/$task"
    git worktree add "$worktree_path" "$task"
  else
    echo "No local or remote branch named '$task' found. Creating new branch from '$default_branch'"
    git worktree add -b "$task" "$worktree_path" "$default_branch"
  fi
  
  if [ $? -eq 0 ]; then
    echo "Worktree created at $worktree_path"
    echo "Installing dependencies..."
    
    # Check if this is a Ruby project and install dependencies
    if [ -f "$worktree_path/Gemfile" ] && command -v bundle >/dev/null; then
      echo "Detected Ruby project - syncing Bundler config from main and running bundle install..."
      # If the main repo has a .bundle/config, copy it so the worktree mirrors main's bundler settings
      if [ -d "$repo_root/.bundle" ]; then
        mkdir -p "$worktree_path/.bundle"
        cp -R "$repo_root/.bundle/" "$worktree_path/.bundle/"
      fi
      (cd "$worktree_path" && bundle install)
    fi
    
    # Check if this is a Node.js project and install dependencies
    if [ -f "$worktree_path/package.json" ] && command -v yarn >/dev/null; then
      echo "Detected Node.js project - running yarn install..."
      (cd "$worktree_path" && yarn install)
    elif [ -f "$worktree_path/package.json" ] && command -v npm >/dev/null; then
      echo "Detected Node.js project - running npm install..."
      (cd "$worktree_path" && npm install)
    fi
    
    # Check for Python projects
    if [ -f "$worktree_path/pyproject.toml" ] && command -v poetry >/dev/null; then
      echo "Detected Poetry project - running poetry install..."
      (cd "$worktree_path" && poetry install)
    elif [ -f "$worktree_path/requirements.txt" ] && command -v pip >/dev/null; then
      echo "Detected Python project - running pip install..."
      (cd "$worktree_path" && pip install -r requirements.txt)
    fi
    
    # Copy .env file from main repo to worktree if it exists
    if [ -f "$repo_root/.env" ]; then
      echo "Copying .env file from main repository..."
      cp "$repo_root/.env" "$worktree_path/.env"
    elif [ -f "$repo_root/.env.example" ]; then
      echo "Copying .env.example file from main repository..."
      cp "$repo_root/.env.example" "$worktree_path/.env"
    else
      echo "No .env or .env.example file found in main repository - skipping environment setup"
    fi
    
    echo "Worktree ready! Use 'wt-enter $task' to navigate to it."
    echo "Repository: $remote_url"
    echo "Default branch: $default_branch"
  else
    echo "Failed to create worktree"
    return 1
  fi
}

# Remove worktree + branch (after merge)
wt-clean() {
  local force=0
  # Parse flags
  while [[ "$1" == -* ]]; do
    case "$1" in
      --force|-f)
        force=1
        shift
        ;;
      *)
        break
        ;;
    esac
  done

  local task="$1"
  [ -z "$task" ] && { echo "usage: wt-clean [--force|-f] <branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Try to find the worktree by searching for directories that contain the task name
  local worktree_path=""
  local found_worktree=""
  
  # First try the truncated name (for new worktrees)
  local truncated_task="${task:0:30}"
  local truncated_path="../${base_name}-wt-${truncated_task}"
  if [ -d "$truncated_path" ]; then
    worktree_path="$truncated_path"
    found_worktree="$truncated_path"
  else
    # Search for existing worktrees with longer names that contain the task
    for dir in "../${base_name}-wt-"*; do
      if [ -d "$dir" ] && [[ "$dir" == *"$task"* ]]; then
        worktree_path="$dir"
        found_worktree="$dir"
        break
      fi
    done
  fi
  
  if [ -z "$found_worktree" ]; then
    echo "Error: No worktree found for branch '$task'"
    echo "Searched in: ../${base_name}-wt-*"
    return 1
  fi
  
  echo "Cleaning up worktree: $task"
  echo "Found worktree at: $found_worktree"
  
  # Check if this worktree is properly registered with git (match EXACT branch)
  local git_worktree_path=""
  git_worktree_path=$(git worktree list --porcelain | awk -v b="$task" '
    $1=="worktree" { path=$2 }
    $1=="branch" && $2=="refs/heads/" b { print path; exit }
  ')
  if [ -n "$git_worktree_path" ]; then
    echo "Git worktree registered at: $git_worktree_path"
    # Use the git-registered path for removal
    if [ "$force" -eq 1 ]; then
      git worktree remove --force "$git_worktree_path" || return 1
    else
      git worktree remove "$git_worktree_path" || return 1
    fi
  else
    echo "Warning: Worktree not found in git worktree list, removing directory manually"
    rm -rf "$found_worktree"
  fi
  
  if [ "$force" -eq 1 ]; then
    git branch -D "$task" 2>/dev/null || true
  else
    git branch -d "$task" 2>/dev/null || echo "Branch not merged; use 'git branch -D $task' to force."
  fi
  git fetch -p
  echo "Worktree cleaned up!"
}

# Quick navigation to worktree
wt-enter() {
  local task="$1"
  [ -z "$task" ] && { echo "usage: wt-enter <branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit task name length to match wt-new function
  local truncated_task="${task:0:30}"
  local worktree_path="../${base_name}-wt-${truncated_task}"
  
  if [ -d "$worktree_path" ]; then
    cd "$worktree_path"
  else
    echo "Worktree $worktree_path not found. Use 'wt-new $task' to create it."
    return 1
  fi
}

# List all worktrees
wt-list() {
  echo "Active worktrees:"
  git worktree list
}

# Get repository info for current directory
wt-info() {
  local remote_url=$(git remote get-url origin 2>/dev/null)
  local default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
  local current_branch=$(git branch --show-current 2>/dev/null)
  
  echo "Repository Information:"
  echo "  Remote URL: $remote_url"
  echo "  Default branch: $default_branch"
  echo "  Current branch: $current_branch"
  echo "  Project type: $(wt-detect-project-type)"
}

# Detect project type based on files present
wt-detect-project-type() {
  local types=()
  
  if [ -f "Gemfile" ]; then
    types+=("Ruby")
  fi
  
  if [ -f "package.json" ]; then
    types+=("Node.js")
  fi
  
  if [ -f "pyproject.toml" ]; then
    types+=("Python (Poetry)")
  elif [ -f "requirements.txt" ]; then
    types+=("Python (pip)")
  fi
  
  if [ ${#types[@]} -eq 0 ]; then
    echo "Unknown"
  else
    echo "${types[*]}"
  fi
}

# Cursor-specific helpers
cursor-open-worktree() {
  local task="$1"
  [ -z "$task" ] && { echo "usage: cursor-open-worktree <branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit task name length to match wt-new function
  local truncated_task="${task:0:30}"
  local worktree_path="../${base_name}-wt-${truncated_task}"
  
  if [ -d "$worktree_path" ]; then
    echo "Opening Cursor with worktree: $worktree_path"
    cursor "$worktree_path"
  else
    echo "Worktree $worktree_path not found. Use 'wt-new $task' to create it."
    return 1
  fi
}

# Rename existing worktree to shorter name to avoid path length issues
wt-rename() {
  local old_task="$1"
  local new_task="$2"
  [ -z "$old_task" ] || [ -z "$new_task" ] && { echo "usage: wt-rename <old-branch-name> <new-branch-name>"; return 1; }
  
  # Get repository root and base name for sibling worktree
  local repo_root="$(pwd)"
  local base_name="$(basename "$repo_root")"
  
  # Limit new task name length
  local truncated_new_task="${new_task:0:30}"
  if [ "${#new_task}" -gt 30 ]; then
    echo "Warning: New task name truncated from '${new_task}' to '${truncated_new_task}' to avoid path length issues with overmind/tmux"
  fi
  
  local old_worktree_path="../${base_name}-wt-${old_task}"
  local new_worktree_path="../${base_name}-wt-${truncated_new_task}"
  
  if [ ! -d "$old_worktree_path" ]; then
    echo "Error: Worktree '$old_worktree_path' not found"
    return 1
  fi
  
  if [ -d "$new_worktree_path" ]; then
    echo "Error: Worktree '$new_worktree_path' already exists"
    return 1
  fi
  
  echo "Renaming worktree from '$old_task' to '$truncated_new_task'"
  echo "Old path: $old_worktree_path"
  echo "New path: $new_worktree_path"
  
  # First, remove the worktree from git's tracking
  echo "Removing worktree from git tracking..."
  git worktree remove "$old_worktree_path" || {
    echo "Warning: Could not remove worktree from git tracking, proceeding with manual cleanup"
  }
  
  # Rename the worktree directory
  mv "$old_worktree_path" "$new_worktree_path"
  
  # Re-register the worktree with the new path
  echo "Re-registering worktree with new path..."
  git worktree add "$new_worktree_path" "$old_task"
  
  echo "Worktree renamed successfully!"
  echo "You can now use 'wt-enter $old_task' to navigate to it."
}

# Detailed worktree diagnostics
wt-diagnose() {
  echo "=== Worktree Diagnostics ==="
  echo ""
  
  # Check current directory
  echo "Current directory: $(pwd)"
  echo "Git root: $(git rev-parse --show-toplevel 2>/dev/null || echo 'Not a git repo')"
  echo ""
  
  # Check worktree list
  echo "=== Git Worktree List ==="
  git worktree list 2>&1 || echo "Failed to get worktree list"
  echo ""
  
  # Check .git/worktrees directory
  local git_dir=".git/worktrees"
  if [ -d "$git_dir" ]; then
    echo "=== .git/worktrees Contents ==="
    ls -la "$git_dir"
    echo ""
    
    # Check each worktree subdirectory
    for subdir in "$git_dir"/*; do
      if [ -d "$subdir" ]; then
        echo "=== Worktree: $(basename "$subdir") ==="
        echo "Path: $(cat "$subdir/gitdir" 2>/dev/null || echo 'No gitdir file')"
        echo "---"
      fi
    done
  else
    echo "No .git/worktrees directory found"
  fi
}

# AI development environment setup
ai-setup() {
  echo "Setting up AI development environment..."
  
  # Check for required tools
  local missing_tools=()
  
  if ! command -v git >/dev/null; then
    missing_tools+=("git")
  fi
  
  if ! command -v cursor >/dev/null; then
    echo "Warning: Cursor not found in PATH. Install from https://cursor.com/downloads"
  fi
  
  if [ ${#missing_tools[@]} -gt 0 ]; then
    echo "Missing required tools: ${missing_tools[*]}"
    return 1
  fi
  
  echo "AI development environment ready!"
  echo ""
  echo "Available worktree commands:"
  echo "  wt-new <branch>     - Create new worktree with automatic dependency installation"
  echo "  wt-enter <branch>   - Navigate to worktree"
  echo "  wt-clean <branch>   - Clean up worktree and branch"
  echo "  wt-list            - List all worktrees"
  echo "  wt-info            - Show repository information"
  echo "  wt-rename <old> <new> - Rename worktree to avoid path length issues"
  echo "  cursor-open-worktree <branch> - Open worktree in Cursor"
  echo ""
  echo "Troubleshooting commands:"
  echo "  wt-diagnose        - Detailed worktree diagnostics"
  echo ""
  echo "Features:"
  echo "  • Automatic branch name truncation (30 chars max) to prevent overmind/tmux path issues"
  echo "  • Smart dependency detection and installation (Ruby, Node.js, Python)"
  echo "  • Environment file copying (.env, .env.example)"
  echo "  • Robust worktree management with automatic path length handling"
  echo ""
  echo "Note: For corrupted worktree issues, use 'wt-diagnose' to identify problems,"
  echo "then manually clean up .git/worktrees/ and .git/config as needed."
}
